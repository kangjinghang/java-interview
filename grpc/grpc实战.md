# 第1章 gRPC概述

## gRPC产生的动机（motivation）

gRPC的动机是什么？或者，gRPC试图解决什么问题？答案是：通信，gRPC是为了解决通信问题而产生的。

### 不同编程语言之间的通信

应用程序使用不同的的编程语言编写的，比如IOS使用swift，后端使用Go/Java。另一方面，当今的趋势是使用微服务架构，即使是在后端，我们也有可能用不通的语言编写不同的服务，比如Go、Python或者Rust。为了在不同的编程语言之间可以进行互相沟通，就必须要一套通用的API协议，比如沟通渠道（是REST还是SOAP还是消息队列），验证机制（Basic、OAuth还是JWT）、消息格式（JSON、XML还是二进制流）、数据模型、如何处理错误等等。

### 通信应该是高效的

微服务之间的消息交换量非常巨大，所以通信应该是越快越好。此外，在某些环境（例如移动应用）中，由于网络速度和带宽受限，一份轻量级的与服务端交互的通信协议是非常重要的。

### 通信应该是简单的

假如我们正在构建一个系统，拥有数百个甚至上千个微服务，我们绝对不想花费大部分时间写很多仅仅是完成服务间通信的代码。我们需要的是一种可以让开发人员专注于实现其服务的核心逻辑的框架，剩下的一切都应该交给框架本身。gRPC正是这种框架。



# 第2章 什么是RPC

## 2.1 初步印象

RPC的语义是远程过程调用，在一般的印象中，就是将一个服务调用封装在一个本地方法中，让调用者像使用本地方法一样调用服务，对其屏蔽实现细节。而具体的实现是通过调用方和服务方的一套约定，基于TCP长连接进行数据交互达成。

上面的解释似云里雾里，仅仅了解到这种程度是远远不够的，还需要更进一步，以相对**底层**和**抽象**的视角来理解RPC。

## 2.2 三个特点

广义上来讲，所有本应用程序外的调用都可以归类为RPC，不管是分布式服务，第三方服务的HTTP接口，还是读写Redis的一次请求。从抽象的角度来讲，它们都一样是RPC，由于不在本地执行，都有三个特点：

- 需要事先约定调用的语义（接口语法）
- 需要网络传输
- 需要约定网络传输中的内容格式

以一次Redis调用为例，执行`redis.set("rpc", 1)`这个调用，其中：

- `set`及其参数`("rpc", 1)`，就是对`调用语义`的约定，由redis的API给出。
- RedisServer会监听一个服务端口，通过TCP传输内容，用异步事件驱动实现高并发。
- 底层库会约定数据如何进行编解码，如何标识命令和参数，如何表示结果，如何表示数据的结尾等等。

这三个特点都是因为`调用不在本地`而不得不衍生出来的问题，也因此决定了RPC的形态。所有的RPC解决方案都是在解决这三个问题，不断地在提出更加优良的解决方案，试图达到更好的性能，更低的使用成本。 本文也将围绕这三个特点来展开内容。

常规的RPC一般都是基于一个大的内部服务，进行分布式拆分，由于其语义上以本地方法的作为入口，那么天然的就更倾向于具备高性能、支持复杂参数和返回值、跨语言等特性。下图是RPC调用的过程示意图：

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635127212.png" alt="image-20211025100012175" style="zoom:50%;" />

## 2.3 内容组织约定

Stub会负责封装命令和参数，并以特定的数据格式进行打包。其中命令、参数和返回值的需要客户端和服务端的Stub事先进行协商，双方都需要维护一份完全一样的方法及参数列表。更进一步需要知道对方如何进行压缩打包，如何压缩结构体，如何压缩Class等等，并严格按照标准进行解压缩，中途有任何一丝的差错都会的导致调用失败。所以一般情况下可能会对数据进行一定的校验，同时要协商方法、参数等错误时如何返回。 这是一个比较繁杂的过程，混合了`调用语法`和 `内容解压缩`两部分内容，可被理解为`如何组织内容`的问题。

## 2.4 网络传输

搞定了协议约定问题后，接下来就是要通过Runtime进行内容传输了，这又是一大难题，一般是需要通过Socket编程来实现，使用TCP或UDP来进行传输，如果是UDP可以用数据报来区分每一次请求和回复。但如果是字节流的TCP，就需要用特殊的方式来标示请求或回复的末尾，用来区分不同的请求。同时当对调用性能有要求时，可能会使用Socket的异步编程模型，消除等待中的消耗，这会引入事件机制，通过状态机来解析处理或回复请求。当出现超时、丢包等情况时还进行做重试、重传、报错等等。

拆解到协议约定和网络传输时，就会发现实现RPC调用是一件非常复杂的事情，自己实现千难万难，接下来就了解一番已有的，针对协议约定和网络传输的解决方案。

当然，在技术高度成熟的今天，已经又很多先烈将传输问题解决掉了，接下来就介绍几款常见的案例组合。

### 2.4.1 ONC RPC

ONC RPC是相对早期的RPC解决方案，通过`外部数据表示法`来约定数据的压缩方式：

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635127512.png" alt="image-20211025100512041" style="zoom:50%;" />

被传输的所有内容都需要通过上面的约定进行压缩，这样接收方就能顺利地按照同样的协议进行解压缩。

对于命令和参数列表的约定，会创建一份公共的协议文件，里面会定义被调用的方法名，参数列表，对象的列表等等。然后用特定工具将文件进行解析生成Stub程序，客户端和服务端都同时将Stub程序放在代码中。比如对方法名进行编号，将`GetUserName(userId)`这个方法编号为1，在调用时就将1传输给服务端，服务端通过协议文件就知道调用的方法，这样节省了大量的空间。

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635127614.png" alt="image-20211025100654757" style="zoom:50%;" />

传输则通过对应的类库实现，通过Socket编程实现的非常复杂的解决方案，包含了超时、失败、异常处理、状态转换等等功能。

这种早期的方案，在每一次代码更新时都需要重新生成Stub程序，调用方和服务方都需要及时更新对应的文件。给某一个方法增加一个默认参数，都需要全部使用者同步升级，从迭代或多版本的场景看来，这是一场噩梦。

### 2.4.2 RESTfull HTTP JSON

RESTfull是一种资源状态转换的架构风格，也可以用来实现RPC， 互联网对HTTP超广泛的支持，使得这相当简单，也是大多数情况下的首选。

通过HTTP协议来进行内容传输，Header用来约定编码、body大小等，彼此以`\r\n`来分割，Header和body之间通过两个连续的`\r\n`来间隔，能很容易地区分不同的请求。

通过Url和对应参数来标示要调用的方法和参数。在body中用JSON对内容进行编码，极易跨语言，不需要约定特定的复杂编码格式和Stub文件。在版本兼容性上非常友好，扩展也很容易。

众多的优点使得这种方案广受欢迎。不过也有其无法避开的弱点：

- HTTP的header和Json的数据冗余和低压缩率使得传输性能差
- JSON难以表达复杂的参数类型，如结构体等

### 2.4.3 gRPC HTTP2.0 Protobuf

gRPC是一款RPC框架，也是本系列的主角，在性能和版本兼容上做了提升和让步：

- Protobuf进行数据编码，提高数据压缩率
- 使用HTTP2.0弥补了HTTP1.1的不足
- 同样在调用方和服务方使用协议约定文件，提供参数可选，为版本兼容留下缓冲空间

[protobuf](https://link.zhihu.com/?target=https%3A//github.com/protocolbuffers/protobuf)是一款用C++开发的跨语言、二进制编码的数据序列化协议，以超高的压缩率著称。它和早期的RPC方案一样，需要双方维护一个协议约束文件，以.proto结尾，使用proto命令对文件进行解析，会生成对应的Stub程序，客户端和服务端都需要保存这份Stub程序用来进行编解码。对于这种协议文件导致的升级困难问题，protobuf 3 中定义的字段默认都是可选的(可以不传)，在接口升级时，部分客户端不需要升级自己的Stub程序。

```pro
// ***.proto文件
syntax = "proto3";
package id_rpc;
message BusinessType {// 定义参数
  string name = 1; //参数字段
}

message UniqueId {// 定义返回值
  uint64 id = 1;
  string business_type = 2;
}

service UniqueIdService {// 定义服务，可以调用 MakeUniqueId 方法
  rpc MakeUniqueId(BusinessType) returns (UniqueId){}
}
```

对于JSON等文本形式的序列化协议来说，protobuf能有几十倍空间和性能提升， 比如传输`123`，文本类的需要3个字节(ascii 31 32 33)来传输，而二进制类只需要一个字节(01111011)就可以表示。

同时protobuf会维护.proto文件，这样在解析文件生成Stub程序时，可以对方法名等进行编号，传输时只传编号，而不用传方法的名字，这又可以节省大量字节，还有其他更多的精巧压缩方法，比如TLV，详情可以参考[proto encoding](https://link.zhihu.com/?target=https%3A//developers.google.com/protocol-buffers/docs/encoding) 。

解决了数据体积的问题后，gRPC使用HTTP2来改善传输性能。 HTTP2是在HTTP1.1的基础上做了大量的改进，HTTP1.1虽然引入了KeepAlive复用TCP连接，但仍然有很多问题：

- 使用KeepAlive的请求是串行执行(非pipeline时)，pipeline时有队首阻塞问题
- 每次都需要发送不必要的Header
- 不能双向通信

简单补充一下pipeline，HTTP1.1中允许多个请求复用连接，同时可以一口气将请求全部发出去，不用一个返回后再发送第二个，提升并发性。而服务端需要将请求的结果，按照pipeline中发送的顺序进行顺序返回，如果靠前的请求阻塞了，那么靠后请求返回就会被动等待。

HTTP2解决了这些问题，引入了新的机制：

- 在两端建立Header索引表，每次只发送索引，减小header体积
- 建立虚拟通道，将数据拆分成多个流，每个流有自己的ID和优先级，并且流可以双向传输，每个流可以进一步拆成多个帧。可以将多个请求切成不同的流发送，每个流可以独立返回，避开1.1的串行或队首阻塞问题。

同时，基于HTTP2的数据流机制，gRPC客户端和服务端可以实现批量操作优化，客户端可以攒一些请求，一口气发给服务端，服务端也可以批量返回结果，借此实现流式rpc。

### 2.4.4 RabbitMQ

rpc作为一种极常见的服务形态，以异步和解耦著称的mq也自然不会放过这个场景，rabbitmq就为rpc调用提供了很好的支持。

一般和rabbitmq的交互场景是发布或消费消息，是一个单向的过程，而rpc却是一种同步的双向交互过程，在使用上有些差异。要理解rabbitmq如何实现rpc，还是可以从上面三个抽象的特点出发，万变不离其宗。

**如何协商调用语义**

mq中的消息是从exchange分发到queue中，消费端在特定的queue中获取消息，rpc的请求依然要走这条路径: `方法调用->exchange->queue->方法执行`。

创建一个direct类型的exchange，让每个rpc方法对应一个queue，这个exchange通过routing_key分发到对应的queue中， 让特定的消费者来实际执行rpc方法。这样rpc方法的语义就通过queue来约定，而方法的参数，可以放入消息中。

**如何将结果传递回客户端**

`方法调用->exchange->queue->方法执行`, 这条路是单行道，方法执行端执行完rpc方法后不能按照原路将结果返回给客户端。要实现结果回传，就得再开辟一条`结果回传端->exchange->queue->结果等待端`路径，一条用来发送rpc请求，另一条用来回传rpc结果，方法调用者和方法执行者都会扮演生产者和消费者。

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635128719.png" alt="image-20211025102519413" style="zoom:50%;" />



rabbitmq中有`回调队列(Callback queue)`来实现`调用结果`回传，同时有`关联ID(Correlation Id)`来唯一标识每一份`调用结果`。

rpc调用方在发送请求时，会在数据中带上回调队列信息(routing_key)和关联ID，rpc执行方在执行完方法后，就将关联ID掺入执行结果中，并将结果通过exchange发往回调队列(通过routing_key)。 rpc调用方在发送请求后，紧接着在设置的回调队列中等结果就行。 整个过程(两条路径)共用同一个exchange。

调用参数和调用结果的打包可以用JSON，protobuf等等，协商一致即可。[完整示例代码](https://link.zhihu.com/?target=http%3A//www.rabbitmq.com/tutorials/tutorial-six-ruby.html)

使用mq实现rpc，有其独有的优势，rpc执行端可以轻松地横向扩展，rpc调用方也不用考虑负载均衡，沿袭了mq解耦的优点。不过对于调用超时，执行端崩溃等等情况得做额外处理。调用方在等待结果时需要设置超时间，高性能的rpc调用还需要调用方能异步高效地通过关联ID将请求结果储存起来，等待调用者获取。[Spring框架的实现方案](https://link.zhihu.com/?target=https%3A//my.oschina.net/u/3967312/blog/2252996)就是用一个HashMap将结果保存起来，等待调用者以关联ID作为key来取结果。





# 第3章 gRPC介绍和工作原理

## 什么是gRPC

gRPC 是一个高性能的开源的功能丰富的通信框架，最初由 Google 开发，现在，它是 Cloud Native Computing Foundation（CNCF） 中的一个项目，就像 Kubernetes 和 Primetheus 。

gRPC 的 “G” 代表什么呢？可能很多人以为是代表 Google ，但是实际上，在每个 gRPC 版本中，它代表不同的事物，比如 good、green、glorious、game 等，甚至是 gRPC 本身，可以查看这个[链接](https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md)，查看完整的列表。

RPC 又是什么呢？RPC 是 Remote Procedure Call 的缩写，代表远程过程调用，这是一种允许程序执行位于其他计算机上的另一个程序的过程的协议，开发人员不必显式地去编码网络交互的细节，因为这是由框架自动处理的。对于我们的客户端来说，我们调用服务端的代码像在本地调用一样简单。



## gRPC工作原理

客户端有一个存根（Stub），它提供了与服务端相同的方法或功能，存根由 gRPC 自动生成，通过网络与服务端交换信息。由于有了存根，客户端和服务端现在只需要关心怎么去实现它们的核心服务逻辑。

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/18/1634570316.png" alt="image-20211018231836117" style="zoom:50%;" />

​															img source：https://grpc.io/docs/what-is-grpc/introduction/



# 第4章 使用 Protocol Buffer 生成代码

为了生成服务端和客户端的存根，我们首先需要编写包括服务描述及有效载荷信息的的API协议。

```protobuf
syntax = "proto3";

message HelloRequest {
	//类型 | 字段名字|  标号
  string name = 1;
}

message HelloResponse {
	// repeated 表示数组
  string greet = 1;
  Value info = 2;         // 可嵌套对象
  map<int, Value> values = 3;    // 可输出map映射
}

message Value {
    bool is_man = 1;
    int age = 2;
}

service WelcomeService {
  rpc Hello(HelloRequest) returns (HelloResponse); // 定义一个RPC方法
}
```

例如，在上面的文件中，定义了 Hello 方法，它以 HelloRequest 作为输入参数，并返回一个 HelloResponse。HelloRequest 只有一个名为 name 的字符串类型的字段，HelloResponse 同样只有一个名为 greet 的字符串类型的字段。

可以看出有几个明确的特点：

- 有明确的类型，支持的类型有多种
- 每个field会有名字
- 每个field有一个**数字标号**，一般按顺序排列(下文编解码会用到这个点)
- 能表达数组、map映射等类型
- 通过嵌套message可以表达复杂的对象
- 方法、参数的定义落到一个.proto 文件中，**依赖双方需要同时持有这个文件，并依此进行编解码**



<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/18/1634572561.png" alt="image-20211018235601365" style="zoom:50%;" />

通过这个 proto 文件和 Protocol Buffer 编译器，可以生成服务端和客户端的存根代码。生成代码时我们需要告诉 Protocol Buffer 编译器使用什么语言的插件帮我们生成代码。

作为一个以跨语言为目标的序列化方案，protobuf 能做到一份 .proto 文件走天下，不管什么语言，都能以同一份 proto 文件作为约定，不用A语言写一份，B语言写一份，各个依赖的服务将proto文件原样拷贝一份即可。

但.proto文件并不是代码，不能执行，要想直接跨语言是不行的，必须得有对应语言的中间代码才行，中间代码要有以下能力：

- 将message转成对象，例如golang里是struct，Ruby里是class，需要各自表达后，才能被理解
- 需要有进行编解码的代码，能解码内容为自己语言的对象、能将对象编码为对应的数据

由于message是自己定义的，而且有特定的类型等，一套通用的编解码代码是不行的(类似json)，特定的proto需要对应的方法，对message编解码，不同的message编解码策略还不一样。

这些代码用手写是不行的，protobuf对此的解决方案是，提供一个统一的protoc工具，这个一个C++”翻译“工具，可以通过proto文件，生成某特定语言的中间代码，实现上面说的两个能力。也就是说，**protobuf通过自动化编译器的方式统一提供了这种能力，避免人肉写**。

```shell
//       依赖目录      生成golang中间代码   对应proto文件地址
protoc -I=$SRC_DIR --go_out=$DST_DIR  $SRC_DIR/XXX.proto
protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/XXX.proto // 生成java中间代码
```

执行结果是对应语言的中间代码，以golang为例，会生成一个xx.pb.go文件，里面就是对应rpc、message的结构体，以及编解码的function。

由于每个field有标号，当proto文件新增字段、message、rpc时也能自然向后兼容，这涉及编解码的策略，下文会详细讨论。



**直观对比**
为什么选择protobuf，而不是普及最广的json作为编码方案？ 可以做一个直观对比，以上文proto中的Response为例，一次输出json的结果是：

```json
"{\"ids\":[123,456],\"info\":{\"is_man\":true,\"age\":20},\"values\":{\"110\":{\"is_man\":false,\"age\":18}}}"
```

所有内容被打包成了一个字符串，里面包含字段名、value，当Reponse很大时，体积消耗很大，浪费主要在三个方面：

- 字段名，例如上面的“ids”、“info”等，如果json体大，则重复会更多
- 数字用字符串表达了，例如123数字变成了“123”，这在编码后体积由一个字节变成三字节
- 类型字符，如[ 、 ]、{ 、}

但如果是protobuf呢？ 输出是一段人眼无法理解的二进制串，里面：

- 去掉了字段名，转而以字段标号替代，通过标号可以在proto中找到字段名
- 没有类型字符等
- 用二进制表达内容，不会将数字转成字符串
- 字段值按顺序依次排列

这使得protobuf的编码结果体积，通常是json编码后的十分之一以下。同时由于排列简单，其解析算法的时空复杂度远小于json，对cpu消耗也小很多。这使得protobuf在大数据量、高频率的数据交互场景下，远胜于json，被大规模分布式RPC场景广泛使用。

**编解码详解**

为什么它能有这个好的压缩效果？ 我们先从编码的角度来思考，如何对一个对象进行编解码。以json编码为例，当遇到下一个字段用`,`隔开就行，遇到下一层级用`{`表示，这样可以将内容依次铺开成一个完整的字符串。解析时按照`{ , }`等字符也能原样还原字段和层次结构。

但protobuf为了减小体积不能使用这些分隔符，抛几个问题：

- 它该怎么`分隔字段`、`表达层次结构`呢？
- 字段value一般分为两种，一种是定长的，例如一个int，它最多4个字节；第二种是变长的，如字符串，你不知道它在哪儿结束。该如何表示？
- 对于定长的int，如果对应值是1，那用4个字节表达是不是有些浪费，该如何节省？

对于此，protobuf将数据类型做了**分类(Wire Type)**，并提供不同的编解码方式：

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635130815.png" alt="image-20211025110015099" style="zoom:50%;" />

值得关注的有两种：

- Varint，解决定长类型的空间浪费，例如值为1的int32只用1字节，避免用四字节，达到压缩的效果。 T - V
- Length-delimi，用来表达长度不定的内容，如string、嵌套数据、数组。 T - L - V

**T - V**

T - V 的含义是：

- T： tag，包含两部分数据： 对应字段的Wire Type(这可以知道是那种分类)， 字段的**数字标号**(tagNum)(可以在proto中找到是哪个字段，**这样就避开了传字段名**)。其打包方式是： **(tagNum<<3) | WireType**
- 如果在proto中没有找到对应的tagNum则会跳过，这样提供了兼容能力
- V： value, 对应字段的值，解析了T，就知道value表达的是哪个字段、什么类型、如何解析了

protobuf编码的结果就是一组组 `T-V`对依次紧凑排列，message有几个字段，就有几对。对于特定的RPC请求，proto中是有明确的请求、回复 message定义的，将T-V对去套对应的message，即可解析出对象。

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635130980.png" alt="image-20211025110300417" style="zoom:50%;" />

紧接着上文预留的一个问题不可跳过，紧凑排列的T-V对，是如何进行分隔的？：

- 如何分隔 T 和 V，该从哪个解析V ？
- 如何分隔 T-V对，该从哪儿开始解析下一对？

T - V 对是一堆紧凑排列二进制串，里面没有分隔符，其解决方案是：

- 征用了每个字节的最高位，如果最高位是1，说明数据没解析完，下个字节还要继续解析，如果字节高位是0，说明当前T或V解析完了，下一个字节开始是其他的T或V
- 类小端排列，高位在➡️，低位左
- 小于 128 的数字 都可以用 1个字节 表示（用8个bit表达7个bit，一bit当作标志位）
- 大于 128 的数字，比如 300(00000001 00101100)，会用两个字节来表示：10101100 00000010 (类小端)

T - V 编码举例：

```protobuf
message request {
    int64 user_id = 1; // tagNum = 1, wireType = 0, 
}

假设 value为 2, 则编码出的T-V为： 
+-----+---+-----------------+
|00001|000|00000010|
+-----+---+-----------------+
tagNum type   data


假设 value为 300, 则编码出的T-V为： 
 第一个字节    第二       第三
+-----+---+-----------------------+
|00001|000| 10101100  00000010| 下个T-V
+-----+---+-----------------------+
tagNum type     data

Tag高位=0： 一个byte
data的第一个字节最高位为1，说明下一个字节还要继续读
```

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635131207.png" alt="image-20211025110647409" style="zoom:50%;" />



**T - L - V**

T - L - V 就是在上面的基础上增加了length，用来表达变长的内容：

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635131252.png" alt="image-20211025110732643" style="zoom:50%;" />

由于是变长，例如数组、嵌套对象，有多个value，此时就无法通过最高位是否是1，来表示该字段是否解析完毕，必须要在value前增加一个length，其他都和T-V一样。

接下来我们学习两个点：

- 数组如何表达
- 嵌套对象如何表达

数组的表达其实比较简单，就是同一个T不断的重复(tagNum和wireType不变)，解析对应的V就行，然后组成一个数组：

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635131418.png" alt="image-20211025111018428" style="zoom:50%;" />

嵌套对象稍微复杂点，每个value都能找到一个message去套，逐层解就行了：

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/25/1635131434.png" alt="image-20211025111034157" style="zoom:50%;" />

嵌套对象编码举例：

```protobuf
message request {
    User user = 1; // tagNum = 1, wireType = 2, 
}
message User {
    int64 user_id = 1; // tagNum = 1
}

假设 request = { user_id: 2}, 则编码出的T-L-V为： 
    Tag     length        value
                       Tag      value
+---------+--------+---------+---------
|00001010 |00000010|000010000|00000010|
 1<<3 | 2   2 byte   1<<3 | 0    2

通过解request 知道第一个字段是User，再拿到第一个字段的value去解User，
知道User第一个字段是int64，解析出data为2。 一个嵌套对象即解析完毕
```

## 优缺点对比

全文到此，基本解释清楚了protobuf如何编解码，以及为什么压缩率会比json高，可以看出其优点有：

- 没有打包无用的数据，排列紧凑，体积小，利于传输
- 解析策略简单，序列化/反序列化 速度快
- 能较好的兼容字段(不能解析到的会跳过)

但缺点也非常明显：

- 肉眼看不出来value是什么，无法自描述， 难以debug
- 需要proto文件才能知道如何解析，否则是天书，这在灵活性上不如json

其实在本质上其差别在于：**json的设计是给人看的，protobuf则是利于机器**。

适用场景不同，各有利弊。作为工具，讨论其快、好、差没有意义，在合适的地方，用合适的工具即可。



## 为什么 gRPC 使用 Protocol Buffer

1. 它是一种非常容易阅读和理解的 IDL（Interface Definition Language） 语言。
2. 通过自动生成的多种语言代码，可以让编程语言之间互相操作。
3. 它用二进制格式表示数据，拥有更小的体积，更快的传输速度和比 JSON/XML 更有效的序列化和反序列化方式。
4. 它在客户端和服务端之间提供了强类型的协议，更加安全。
5. 对于 API 的演进更加方便，确保了向前和向后的兼容性。

既然  Protocol Buffer 拥有这么多好处，那么 gRPC 必须使用 Protocol Buffer 吗？不是的，我们可以改用 Google Flatbuffers 或者 Microsoft Bond，但是 Protocol Buffer 的确是一个非常棒的选择。





## gRPC 支持什么编程语言

11种官方支持的编程语言：C#、C++、Dart、Go、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby。

此外，还有许多其他语言的非官方库，例如 Swift、Rust、Typescript 等。



# 第5章 HTTP/2在 gRPC 中的应用

## 为什么 HTTP/2 让 gRPC 更高效

gRPC 使用 HTTP/2 作为其传输协议，因此，gRPC 也继承了HTTP/2 提供的一些出色的功能，例如二进制框架。

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634573266.png" alt="image-20211019000746837" style="zoom:50%;" />

- 二进制框架
  - 更高和更强大的性能
  - 传输更轻便，解码更安全
  - 因为 HTTP/2 也是二进制， 所以与 Protocol Buffer 可以更好的结合
- 使用 HPACK 压缩标头
  - 减少开销和提升性能
- 多路复用
  - 客户端和服务端可以通过一个 TCP 连接并行发送多个请求和响应
  - 有助于降低延迟和提高网络利用率
- 服务端推送
  - 在客户端发出当请求的情况下，服务端可以发回多个响应
  - 在许多情况下，可以显著的减少服务端和客户端之间的往返延迟



## HTTP/2 是如何工作的

- 一个 TCP 连接可以承载多个双向流。
- 每个流具有唯一的标识符并携带多个双向消息。
- 每个消息（可以是请求或响应）都可以分解为多个二进制帧。
- 帧是承载不同类型数据的最小单位，例如：HEADERS、SETTINGS、PRIORITY、DATA 等等。
- 多个流的二进制帧是互相交错的，并且在到达另一端时完成组装。

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634574142.png" alt="image-20211019002222713" style="zoom:50%;" />



在了解了 HTTP/2 的工作原理后，我们来和 HTTP/1.1 做一个比较，看一下它们之间的差异。

|                  | HTTP/2     | HTTP/1.1   |
| ---------------- | ---------- | ---------- |
| 传输协议         | 二进制协议 | 超文本协议 |
| 标头（HEADERS）  | 压缩的     | 纯文本     |
| 每个连接的请求数 | 多个       | 一个       |
| 服务端推送       | 支持       | 不支持     |
| RELEASE 时间     | 2015       | 1997       |

<img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634574426.png" alt="image-20211019002706625" style="zoom:50%;" />



# 第6章 gRPC 示例和与 REST 对比

gRPC 的通信方式有4种类型：

- 一元（ UNARY）：客户端发送单个请求消息，服务端返回单个响应消息

  <img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634574888.png" alt="image-20211019003448809" style="zoom:50%;" />

- 客户端流（CLIENT STREAMING）：客户端发送多个消息流，服务端返回单个响应

  <img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634574902.png" alt="image-20211019003502228" style="zoom:50%;" />

- 服务端（SERVER STREAMING）：客户端发送单个请求消息，服务端回复多个消息流

  <img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634574915.png" alt="image-20211019003515952" style="zoom:50%;" />

- 双向流式传输（BIDIRECTIONAL STREAMING）：客户端和服务端并行持续发送和接受多条消息，可以以任何顺序，非常灵活且无阻塞。这意味着，任何一方都无需在下一条消息之前等待响应。

  <img src="http://blog-1259650185.cosbj.myqcloud.com/img/202110/19/1634574926.png" alt="image-20211019003526031" style="zoom:50%;" />



下面我们来比较一下 gRPC 与 REST，了解它们之间的差异。

|            | gRPC                         | REST                        |
| ---------- | ---------------------------- | --------------------------- |
| 传输协议   | HTTP/2（高速）               | HTTP/1.1（慢速）            |
| 载荷       | ProtoBuf（二进制、体积更小） | JSON（文本、体积更大）      |
| API 协议   | 严格的，强制的（.proto）     | 宽松的、非强制的（OpenAPI） |
| 代码生成   | 内建的（protoc）             | 借助第三方工具（Swagger等） |
| 安全       | TSL/SSL                      | TSL/SSL                     |
| 流向       | 双向流                       | 客户端到服务端的单向流      |
| 浏览器支持 | 有限的（需要 gRPC-web）      | 支持                        |



## gRPC适合使用的场景

适合在微服务场景中使用

- 因为具有低延迟和高吞吐量的通信方式
- 强大的 API 协议定义

也适合在多语言环境中使用

- 为许多编程语言提供了开箱即用的代码生成功能

还有，点对点的实时通信场景

- 对双向流提供了出色的支持

最后，网络受限的环境（例如移动应用），gRPC 也是一个不错的选择。因为它拥有轻量级的消息格式。





# 参考

[tech-school gRPC系列教程](https://www.youtube.com/watch?v=2Sm_O75I7H0)

[知乎-渔人-gRPC系列](https://zhuanlan.zhihu.com/p/148139089)

