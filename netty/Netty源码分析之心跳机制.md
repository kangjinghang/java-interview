## 什么是心跳机制？

心跳说的是在客户端和服务端在互相建立ESTABLISH状态的时候，如何通过发送一个最简单的包来**保持连接的存活**，还有**监控另一边服务的可用性**等。

## 心跳包的作用

- **保活**

  Q：为什么说心跳机制能保持连接的存活，它是集群中或长连接中最为有效避免网络中断的一个重要的保障措施？
  A：之所以说是"避免网络中断的一个重要保障措施"，原因是：我们得知公网IP是一个宝贵的资源，一旦某一连接长时间的占用并且不发数据，这怎能对得起网络给此连接分配公网IP，这简直是对网络资源最大的浪费，所以基本上所有的NAT路由器都会定时的清除那些长时间没有数据传输的映射表项。一是回收IP资源，二是释放NAT路由器本身内存的资源，这样问题就来了，连接被从中间断开了，双发还都不晓得对方已经连通不了了，还会继续发数据，这样会有两个结果：a) 发方会收到NAT路由器的RST包，导致发方知道连接已中断；b) 发方没有收到任何NAT的回执，NAT只是简单的drop相应的数据包。
  通常我们测试得出的是第二种情况会多些，就是客户端是不知道自己应经连接断开了，所以这时候心跳就可以和NAT建立关联了，只要我们在NAT认为合理连接的时间内发送心跳数据包，这样NAT会继续keep连接的IP映射表项不被移除，达到了连接不会被中断的目的。

- **检测另一端服务是否可用**

​		TCP的断开可能有时候是不能瞬时探知的，甚至是不能探知的，也可能有很长时间的延迟，如果前端没有正常的断开TCP连接，四次		握手没有发起，服务端无从得知客户端的掉线，这个时候我们就需要心跳包来检测另一端服务是否还存活可用。

## 应用层的心跳机制  VS  TCP的keepalive机制

- 传输层心跳是保证连接可用，但应用层心跳却可以保证服务可用。
  TCP的keepalive机制能保证连接没有问题，但当进程出现死锁或者阻塞的情况下，虽然连接没有问题，但是服务已经不能正常使用了。
- 从TCP的keepalive机制的本质上来说，是用来检测长时间不活跃的连接的，不适合用来及时检测连接的状态；而应用层的心跳机制具有更大的灵活性，可以自己控制检测的间隔和检测方式，并且可以通过心跳包来附带一些信息等。
  TCP有个KeepAlive开关，打开后可以用来检测死连接。通常默认是2小时，可以自己设置。但是注意，这是TCP的全局设置。

## 用 Netty 的 IdleStateHandler 实现固定周期的心跳机制

因为IdleStateHandler的超时时间是不可改变的，所以通过IdleStateHandler只能实现固定周期的心跳机制。

以此为基础的心跳机制：

方案一：

client:

1. arg0.pipeline().addLast("ping", new IdleStateHandler(25, 0, 10,TimeUnit.SECONDS));
   处理ReadIdleEvent和AllIdleEvent。
   当AllIdleEvent触发时说明此时间段内既没有读也没有写操作，那么就发送一个心跳包。
   因为ReadIdleEvent的超时时间比AllIdleEvent长，所以如果在指定时间范围内收到了心跳包的回复是不会触发这个事件的。所以如果ReadIdleEvent事件被触发了，则认为和服务端的连接已经断掉了，那么就close这个channel。👈注意，这边有个有个优化，每次发送心跳包的时候就计数下，如果有收到pong包则重新计数，依次来实现发送N此心跳包后依旧么有回复的情况下，再关闭这个channel。
2. 通过channelInactive方法来处理客户端的重连机制的。该方法触发使，会调用一个延迟器来执行和服务端的重连。

server：
arg0.pipeline().addLast("ping", new IdleStateHandler(25 * N, 0, 0,TimeUnit.SECONDS));
N为客户端重试发送心跳包的次数，这么设计主要是为了让客户端和服务端能几乎同时的去关闭这个channel。
当ReadIdleEvent被触发时，则认为和客户端的这次连接已经断掉了，则close这个channel。





## 参考

[Netty 那些事儿 ——— 心跳机制](https://www.jianshu.com/p/c187d1b649c6)
